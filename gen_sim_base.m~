%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%   Generate NEK input files (.rea, .bc)                                  %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%addpath('/scratch/nicolo/work/matlab-library/nek/')
addpath('/scratch/josfa/matlab-tools/nek/')
clc, close all, clear all



%% Parameters

% Grid
gridname = 'FST_naca0008'; runnek = 0; % -> run Nek in gridname-init by yourself because you need the right values in the SIZE file


% Initial condition (if none data from grid file)
% icdata = 'bc_morino/alphaexp-2.5.mat';
% bldata = 'bc_morino/bl-data.mat';


% Simulation
simname = 'FST_naca0008-base';

Re = 5.333333e5;%3.75e6;
%U  = 10; <- needed only if icdata exists

% -- boundary conditions for each boundary (W: wall, v: Dirichlet, O: Neumann)
bc{0+1} = 'E'; % no bc for internal nodes
bc{1+1} = 'W';
bc{2+1} = 'o';
bc{3+1} = 'v';
bc{4+1} = 'v';
bc{5+1} = 'v';
bc{6+1} = 'o';

% -- fringe
stfr = 0.0;



%% Load grid
[xx,yy,ii,uu,vv,pp,fr] = read_grid(gridname); [nely,nelx] = size(xx(2:end,2:end));



%% Initial/Boundary condition 
if exist('icdata','var')
    
    % generate from potential solution
    mo = load(icdata);
    [uu,vv,pp] = morinoflowfield(mo.pan+mo.dpan,mo.cll+mo.dcll,mo.alpha,mo.phi,xx,yy);
    
    % rescale velocity
    uu = U * uu; vv = U * vv; pp = 1 - (uu.^2 + vv.^2)/2;
    
    % fix boundary layer
    bl = load(bldata);
    dstfun = @(m) interp1(bl.m,bl.dst,m,'spline');
    ublfun = @(eta,m) interp2(bl.m,bl.yy,squeeze(bl.ff(2,:,:)),m,eta,'spline',1);
    etamax = min([max(bl.yy) 20])
    
    % wall normal direction
    n = [xx(end,:) - xx(1,:);
         yy(end,:) - yy(1,:)]; n = n./([1 1]' * sqrt(n(1,:).^2 + n(2,:).^2));
    
    % tangential coordinate
    dx = xx(1,2:end) - xx(1,1:end-1);
    dy = yy(1,2:end) - yy(1,1:end-1);

    ds = sqrt(dx.^2+dy.^2);
    spr = cumsum([0 ds]); [~,ispr0] = min(abs(xx(1,:))); spr = spr - spr(ispr0);
    
    % boundary layer characteristics
    mbl = interp1(mo.scll,mo.m,spr,'spline');
    deltabl = interp1(mo.scll,mo.delta,spr,'spline');
    
    for i = 1:nelx+1
        
        % boundary layer coordinate
        etabl = n(:,i)' * [ xx(:,i)' - xx(1,i) ;
                            yy(:,i)' - yy(1,i) ] ./ deltabl(i);
        jj = etabl <= etamax;
        
        % regularize velocity (close to the wall)
        method = 'linear';
        uu(jj,i) = interp1(etabl(~jj),uu(~jj,i),etabl(jj),method,'extrap');
        vv(jj,i) = interp1(etabl(~jj),vv(~jj,i),etabl(jj),method,'extrap');
        pp(jj,i) = 1 - (uu(jj,i).^2 + vv(jj,i).^2)/2;
        
        % map boundary layer to grid
        uu(jj,i) = ublfun(etabl(jj),mbl(i)) .* uu(jj,i);
        vv(jj,i) = ublfun(etabl(jj),mbl(i)) .* vv(jj,i);
        
    end
    
end



%% Plot grid and ic/bc
figure(1); clf; hold on; set (1,'Units','normalized','Position',[.5 .5 .5 .5]);

%hh = surf(xx,yy,uu,'EdgeColor','none'); hc = colorbar('NO'); xlabel(hc,'u')
%hh = surf(xx,yy,vv,'EdgeColor','none'); hc = colorbar('NO'); xlabel(hc,'v')
hh = surf(xx,yy,pp,'EdgeColor','none'); hc = colorbar('NO'); xlabel(hc,'p')
os = max(max(get(hh,'ZData')));

clrs = 'rgbcmy';
for i = 1:max(max(max(ii)))
    bd = sum(ii==i,3)~=0;
    hbd(i) = plot3(xx(bd),yy(bd),os+0*xx(bd),...
                   clrs(mod(i-1,6)+1),'LineWidth',1.5); % boundaries
    lgd{i} = ['boundary ',(num2str(i)),' (',bc{i+1},')'];
end
        
legend(hbd,lgd,'Location','SO','Orientation','Horizontal');

hold off; view(2); axis image; grid on
xlabel('x/c'); ylabel('y/c'); title('Grid'); drawnow



%% Build mesh

% gridpoints numbering
iind = 1:(nelx+1)*(nely+1);
iind = reshape(iind,nely+1,nelx+1);

% generate elements
nel = nelx*nely;

iel = 0;
for i = 1:nelx
    for j = 1:nely
        % element id
        iel = iel+1;
        
        % corners
        EL(iel).nodenum = [iel iind(j,i) iind(j,i+1) iind(j+1,i+1) iind(j+1,i)];
        EL(iel).nodes(1,:) = [xx(j,i) xx(j,i+1) xx(j+1,i+1) xx(j+1,i)];
        EL(iel).nodes(2,:) = [yy(j,i) yy(j,i+1) yy(j+1,i+1) yy(j+1,i)];
        
        % bc
        EL(iel).BC = [ bc{ii(j  ,i  ,1)+1} ...
                       bc{ii(j  ,i+1,4)+1} ...
                       bc{ii(j+1,i+1,3)+1} ...
                       bc{ii(j+1,i  ,2)+1} ];
        
    end
end



%% Run NEK5000
if runnek
system(['rm -r ',gridname,'-init']);
system(['mkdir ',gridname,'-init']);
system('module unload pgi openmpi-pgi');

% write rea
write_rea(EL,[gridname,'-init/',gridname],2);

% get NEK
system(['cd ',gridname,'-init; getnek ',gridname]);

% run NEK
system(['cd ',gridname,'-init; genmap < genmap.i; ./nekmpi ',gridname,' 8']);
end



%% Get GLL points

% read flow field
[nekdata,lr1,elmap,~,~,fields,emode,wdsz,etag,hdr] = readnek([gridname,'-init/',gridname,'0.f00001']);

nel = length(elmap);

% save GLL points in EL structure
for iel = 1:nel
    EL(iel).GLL(:,1) = squeeze(nekdata(iel,:,1));
    EL(iel).GLL(:,2) = squeeze(nekdata(iel,:,2));
end

% reshape gll points
[xxic,yyic] = reshapenek(nekdata,nelx,nely);

clear nekdata



%% Interpolate data from .grid to GLL points

% create an index-based grid
% - grid
igr = 1:(lr1(1)-1):size(xxic,2);
jgr = 1:(lr1(2)-1):size(xxic,1);

[iigr,jjgr] = meshgrid(igr,jgr);

% - gll
ptmap = (1-cos(linspace(0,pi,lr1(1))))/2 * (lr1(1)-1);
igll = zeros(1,size(xxic,2));
for ielx = 1:nelx
    ii = (0:lr1(1)-1) + (lr1(1)-1)*(ielx-1) + 1;
    igll(ii) = ptmap + (lr1(1)-1)*(ielx-1) + 1;
end

ptmap = (1-cos(linspace(0,pi,lr1(2))))/2 * (lr1(2)-1);
jgll = zeros(1,size(xxic,1));
for iely = 1:nely
    jj = (0:lr1(2)-1) + (lr1(2)-1)*(iely-1) + 1;
    jgll(jj) = ptmap + (lr1(2)-1)*(iely-1) + 1;
end
    
[iigll,jjgll] = meshgrid(igll,jgll);

% interpolate fringe
method = 'cubic';
uuic = interp2(iigr,jjgr,uu,iigll,jjgll,method);
vvic = interp2(iigr,jjgr,vv,iigll,jjgll,method);
ppic = interp2(iigr,jjgr,pp,iigll,jjgll,method);
ffic = interp2(iigr,jjgr,fr,iigll,jjgll,method);
ffic(ffic<2*eps) = 0; ffic = ffic * stfr/max(max(abs(ffic)));



%% Pressure for outflow bc nodes as negative fringe (check simname.usr for consistency)

% lgl derivative
[Dlgl,xlgl] = lgldif(lr1(1)); xlgl = (1-xlgl)/2; Dlgl = -Dlgl*2;

%
if strcmp(bc{2+1},'o')
    ibc  = size(xxic,2);
    %enx = xxic(:,ibc) - xxic(:,ibc-1);
    ibel = ibc-(lr1(1)-1):ibc;
    lbel = sqrt( (xxic(:,ibel(end)) - xxic(:,ibel(1))).^2 ...
               + (yyic(:,ibel(end)) - yyic(:,ibel(1))).^2 );
           
    % ambient pressure (pa = -1/Re dU/dx + p)
    dudx = uuic(:,ibel) * Dlgl(end,:)' ./ lbel;
    pa = ppic(:,ibc) - 1/Re * dudx;
    
    % pa as negative fringe
    ffic(:,ibc) = -pa;
end

if strcmp(bc{6+1},'o')
    ibc  = 1;
    ibel = ibc:ibc+(lr1(1)-1);
    lbel = sqrt( (xxic(:,ibel(end)) - xxic(:,ibel(1))).^2 ...
               + (yyic(:,ibel(end)) - yyic(:,ibel(1))).^2 );
           
    % ambient pressure (pa = p-1/Re dU/dn)
    dudx = uuic(:,ibel) * Dlgl(end,:)' ./ lbel;
    pa = ppic(:,ibc) - 1/Re * dudx;
    
    % pa as negative fringe
    ffic(:,ibc) = -pa;
end




%% Reshape data in EL structure 
for ielx = 1:nelx
	for iely = 1:nely
            
        iel = iely + nely*(ielx-1);
            
        ii = (0:lr1(1)-1) + (lr1(1)-1)*(ielx-1) + 1;
        jj = (0:lr1(2)-1) + (lr1(2)-1)*(iely-1) + 1;
        
        EL(iel).FLD(:,1) = reshape(uuic(jj,ii)',lr1(1)*lr1(2),1);
        EL(iel).FLD(:,2) = reshape(vvic(jj,ii)',lr1(1)*lr1(2),1);
        EL(iel).PRS(:,1) = reshape(ppic(jj,ii)',lr1(1)*lr1(2),1);
        EL(iel).FRI(:,1) = reshape(ffic(jj,ii)',lr1(1)*lr1(2),1);
            
	end
end

% check interpolation for NaN
if (sum(sum(isnan(uuic))) ~= 0)|(sum(sum(isnan(vvic))) ~= 0)|(sum(sum(isnan(ppic))) ~= 0)
    disp(' Error: NaN values from griddata.')
    return
end

clear xgll ygll ugll vgll pgll fgll



%% Write initial/boundary condition with fringe

% reshape data for writing
nekdata = zeros(nel,lr1(1)*lr1(2),6);
for iel = 1:nel
    nekdata(iel,:,1) = EL(iel).GLL(:,1);
    nekdata(iel,:,2) = EL(iel).GLL(:,2);
    nekdata(iel,:,3) = EL(iel).FLD(:,1);
    nekdata(iel,:,4) = EL(iel).FLD(:,2);
    nekdata(iel,:,5) = EL(iel).PRS(:,1);
    nekdata(iel,:,6) = EL(iel).FRI(:,1);
end

% write initial condition file
status = writenek([simname,'.bc'],nekdata,lr1,elmap,0,0,fields,emode,wdsz,etag);



%% Write .rea
param = init_param();
param(  2) = -Re;   % RE
param( 11) = 1.0e+6;% NSTEPS
param( 12) = 2.0e-5;% DT
param( 15) = 2.0e+4;% IOSTEP
param( 33) = 0;     % .1 ratio Re ramp
param( 34) = 0;     % 1.0 t0    Re ramp
param( 35) = 0;     % 6.0 tend  Re ramp
param( 63) = 1;     % real8 output files
param( 70) = 1e3;   % proper restart update time
param( 94) = 0;     % start projecting velocity after p94 step (0 to disable vel proj)

write_rea(EL,simname,2,'BCfile',[simname,'.bc'],param);



%% Generate simulation folder
system(sprintf('mkdir     ../base-torun/%s',simname));
system(sprintf('cp %s.rea ../base-torun/%s',simname,simname));
system(sprintf('cp %s.bc  ../base-torun/%s',simname,simname));



%% Finilze script

% remove initialization file
% system(['rm -r ',gridname,'-init']);

% prepare .ic for visualisation
status = writenek([simname,'.bc0.f00001'],nekdata,lr1,elmap,0,0,fields,emode,8,etag); % Use 4 instead of 8 if visit version is below 2.10
system(['visnek ',simname,'.bc']);

%clear nekdata
